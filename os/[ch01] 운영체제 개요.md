# 운영체제란?

## 운영체제의 정의

컴퓨터를 사용하여 `특정 목적`을 유용하게 달성하기 위한 도구.

1.  하드웨어를 관리하는 소프트웨어.
2.  하드웨어와 사용자 사이를 중재하는 소프트웨어.

<br/>

## 운영체제의 목적

각 운영체제에는 달성하고자할 `목적`이 있으며 `시스템의 크기`에 따라 목적이 달라집니다.

-   `대형 시스템` : 하드웨어 사용 최적화.
-   `중형 시스템` : 대형 시스템과 소형 시스템의 중간지점.
-   `소형 시스템` : 사용자가 편리하게 사용할 수 있는 인터페이스 제공.

<br/>

## 프로그램의 구분

-   `커널` : 운영체제의 핵심. 항상 실행되는 프로그램.
-   `시스템 프로그램` : 운영체제와 연관되어 있으나 `커널의 일부분`은 아닌 프로그램.
-   `응용 프로그램` : 그 이외의 프로그램.

<br/>

## 부트스트랩과 Init

컴퓨터에 전원이 인가될 때 처음 실행되는 프로그램으로 `펌웨어` 또는 `ROM`에 위치합니다. 커널을 관리하는 프로그램인 `init`을 시작시키는 역할을 합니다.

<br/>

# 현대 운영체제 구조

## 인터럽트

### Interrupt Driven System

운영체제는 평소에 아무것도 하지 않으며 `인터럽트`에 의해서만 움직이기 때문에, 현대 운영체제는 `인터럽트 주도 시스템`이라고 불립니다.

1.  `시스템 버스`를 통해 `인터럽트`가 CPU에 전달된다.
2.  `현재 상태`를 백업하고 해당 인터럽트를 처리하는 `서비스 루틴`을 실행시킨다.
3.  백업된 정보를 사용하여 `이전 상태`로 복구한다.

<br/>

### 인터럽트 종류

`인터럽트가 발생된 위치`에 따라 명칭이 달라집니다.

<br/>

-   `외부 인터럽트` : 하드웨어 수준에서 발생한 인터럽트. `트랩`이라고 부릅니다.
    -   갑자기 전원이 끊긴 경우.
    -   하드웨어 타이머가 만료된 경우. ex) 왓치독 타이머

<br/>

-   `내부 인터럽트` : 소프트웨어 수준에서 발생한 인터럽트. `익셉션`이라고 부릅니다.
    -   0으로 나누는 등, 잘못된 연산을 수행하려는 경우 → `프로그램 검사 인터럽트`
    -   커널이 필요에 의해 일으킨 경우 → `슈퍼바이저 콜`
    -   데이터 입출력을 다루는 경우 → `I/O 인터럽트`

<br/>

### 인터럽트 우선순위

인터럽트 도중이라도 `더 높은 우선순위`를 갖는 인터럽트가 발생하면 해당 인터럽트가 우선적으로 처리됩니다. 기본적으로는 `외부 인터럽트`가 우선적으로 처리된 뒤에 `내부 인터럽트`가 처리됩니다. 구체적인 순위는 다음과 같습니다.

1.  `외부 인터럽트`
2.  `프로그램 검사 인터럽트`
3.  `슈퍼바이저 콜`
4.  `I/O 인터럽트`

<br/>

### 인터럽트 회선개수

`인터럽트를 받아들이는 회선의 개수`에 따라 구조적 명칭이 달라집니다.

<br/>

-   `단일 회선 방식`

모든 인터럽트가 하나의 회선을 통해 들어옵니다. 이 경우에는 `CPU`가 `인터럽트를 처리할 수 있는 서비스 루틴의 주소`를 알아낼 수 있도록 힌트를 함께 주어야 합니다. `서비스 루틴`의 주소를 알아내는 방식에 따라 `폴링 방식` 또는 `벡터 방식`으로 나뉩니다.

<br/>

**폴링 방식 :**

`폴링 방식`에서 인터럽트가 발생하면 `인터럽트의 원인이 되는 디바이스`의 `인터럽트 플래그`가 1로 설정됩니다. `CPU`가 주기적으로 `인터럽트 회선`을 검사하다가 인터럽트를 감지하면 `인터럽트 플래그`가 1로 설정된 디바이스를 찾아내어, 해당 디바이스가 미리 정의한 서비스 루틴을 실행합니다. 구현하기 쉽지만, 일정 주기마다 검사해야 하기 때문에 `리소스`를 많이 잡아먹고 `주기에 따른 딜레이`도 있습니다.

<br/>

**벡터 방식 :**

`벡터 방식`에서 인터럽트가 발생하면 `인터럽트를 처리할 수 있는 서비스 루틴의 주소`가 함께 전달되며, `CPU`가 인터럽트 신호를 받으면 함께 전달된 `서비스 루틴`을 실행합니다.

<br/>

-   `다중 회선 방식`

각각의 인터럽트가 자신만의 회선을 통해 들어옵니다. `CPU`가 인터럽트의 원인을 즉시 판별할 수 있으나 `회로 복잡도`가 증가합니다.

<br/>

-   `혼합 회선 방식`

위의 두 방식이 혼합된 형태입니다.

<br/>

## 메모리 적재

### 폰 노이만 구조

`저장된 프로그램`(`Stored-Program`)개념이 도입된 구조입니다. 모든 프로그램과 데이터는 `메모리`에 올라오고 나서야 사용할 수 있습니다. 그러나 대용량 데이터 또는 프로그램은 `메모리`에 올라오는 과정에서 병목이 발생할 수 있는데 이것을 `폰 노이만 병목`이라고 부릅니다.

<br/>

### 적재와 저장

`CPU`가 한번에 읽고 쓸 수 있는 용량단위를 `워드`라고 부릅니다. `CPU`가 `Device`에서 하나의 워드를 읽어오는 것을 `적재`라고 하며, `CPU`가 `Device`에 하나의 워드를 쓰는 것을 `저장`이라고 합니다. 이것들은 `I/O 인터럽트`에 의해 발생하며 `CPU`가 알맞은 서비스 루틴을 실행해야 하기 때문에 `CPU 독점적인 작업`이라는 것을 의미합니다. 쉽게 말하자면, 인터럽트를 처리할 서비스 루틴도 하나의 프로그램이기 때문에 `CPU`가 다른 작업을 진행할 수 없다는 것입니다.

<br/>

### 직접 메모리 접근 (DMA)

적재와 저장이 발생하면 `그 동안 CPU는 다른일을 못한다`라는 것을 이해하셨을겁니다. 이런 상황에서 `대용량 데이터 입출력`이 발생한다면 그 동안 다른일을 하지 못하니 엄청난 손실이 발생하겠죠. 따라서 `CPU의 통제에서 벗어난 입출력 방식`이 개발되었으며 이것을 `직접 메모리 접근`이라고 부릅니다.

<br/>

`DMA`는 `CPU`가 `I/O 서비스 루틴`을 수행하지 않아도 `Device`와 데이터를 주고받을 수 있습니다. `DMA 처리기`가 대신 `I/O 서비스 루틴`을 실행해주기 때문이죠. `DMA 시작 인터럽트`가 발생하면 `CPU`가 해당 `Target Device`의 입출력 제어권을 `DMA 처리기`에 넘기고 자신은 다른 작업을 수행합니다.

<br/>

`DMA`가 끝나면 `DMA 처리기`는 `CPU`에게 부여받은 `특정 디바이스의 입출력 제어권`을 돌려줘야 하겠죠. 제어권의 반환은 `DMA 종료 인터럽트` 서비스 루틴에 의해 수행됩니다.

<br/>

## 제어권 관리

### 이중 동작 모드

`커널`과 `일반 프로그램`의 실행을 명확히 구분할 수 있어야 합니다. 권한이 다르게 부여되어야 하기 때문이죠. `일반 프로그램`이 `커널`의 권한을 취득하는 것은 명백한 `해킹 시도`임을 알아야 합니다. 이러한 기능은 `모드 비트`에 의해 구분됩니다.

<br/>

-   `커널 모드` : 모드 비트가 0
-   `일반 모드` : 모드 비트가 1

<br/>

### 독점 방지 타이머

커널이 아닌 프로그램이 `CPU`를 독점할 수 없도록 보장하는 기능입니다. 타이머의 값이 음수가 되었을 때 인터럽트가 발생하며 강제적으로 `문맥 교환`(`Context Swtiching`)을 일으킵니다. 문맥 교환을 일으킨 뒤에 다시 초기값으로 재설정됩니다.

<br/>

## 처리기 구조

`처리기`(`CPU`)는 만들어진 목적에 따라 명칭이 나뉩니다.

<br/>

-   `범용 처리기` : 다양한 목적으로 사용될 수 있는 처리기. ex) `CPU`
-   `전용 처리기` : 특수한 목적을 위해 사용되는 처리기
    -   `DMA 처리기` : 입출력 담당.
    -   `키보드 처리기` : 키보드 신호 해석 담당.

<br/>

### 다중 처리기

시스템은 `범용 처리기` 개수에 따라 명칭이 나뉩니다.

<br/>

-   `단일 처리기 시스템` : `CPU`가 하나만 있는 시스템.
-   `다중 처리기 시스템` : `CPU`가 여러개 있는 시스템.

<br/>

`다중 처리기 시스템`의 강점을 나열해보면 다음과 같습니다.

<br/>

1.  `처리량 증가`

`CPU`가 여러개 있으니 `동일 시간당 처리량`이 증가하겠죠. 그렇지만 여러개의 `CPU`를 감독하는 과정에서 약간의 오버헤드가 있으므로 처리량이 항상 `N배`로 증가하는 것은 아닙니다.

<br/>

2.  `규모의 경제`

`주변장치`를 공유할 수 있어 비용이 절약됩니다. 단일 처리기 시스템이였다면, 각 시스템 마다 여러개의 `주변장치`가 필요해지겠죠,

<br/>

3.  `신뢰성 증가`

어떤 `CPU`가 고장나더라도 다른 `CPU`가 있으므로 시스템이 정지하지 않습니다. 처리량이 좀 줄어드는 것은 어쩔 수 없지만, 처리기 중 하나가 고장나는 것이, 전체 시스템이 정지하는 것 보다 훨씬 낫습니다. 이것을 `결함 허용`(`fault tolerant`)라고 합니다.

<br/>

### 다중 처리기 시스템의 분류

여러개의 `CPU`가 동등한 역할을 맡았는지 여부에 따라 명칭이 나뉩니다.

<br/>

-   `대칭적 시스템` : 모든 `CPU`가 동등한 역할을 수행.
-   `비대칭적 시스템` : 하나의 `CPU`가 다른 `CPU`를 감시하고 작업을 분배하는 역할을 수행.

<br/>

다중 처리기 시스템은 `동일한 메모리`를 공유하면서(`레지스터`와 `캐시`는 각각의 처리기 마다 달려있으므로 제외) `동일 프로그램`을 실행해야 하기 때문에 `하드웨어 제어권` 및 `어떤 처리기가 어떤 작업을 맡을것인지`결정해야 합니다. 각각의 처리기가 균등하게 작업이 분할된다면 가장 처리량이 높겠죠.

<br/>

`비대칭적 시스템`은 이러한 역할을 하는 `Master CPU`를 두어 시스템을 운용합니다. 하지만 `Master`는 다른 작업을 맡지 않으므로 성능이 약간 하락합니다.

<br/>

`대칭적 시스템`은 모두가 `Slave CPU`이므로 각각의 `CPU`를 온전히 사용할 수 있습니다. 그러나 특정 `CPU`에만 작업이 집중되는 현상이 발생할 수 있습니다.

<br/>

### 다중 처리기 칩 (멀티코어)

요즘은 `여러개의 CPU를 다는 것`보다 `하나의 CPU에 여러개의 코어를 넣는 것`이 훨씬 효율적입니다. `서로다른 CPU간 통신`보다 `동일 CPU내의 서로다른 코어간 통신`이 훨씬 빠르고 소비전력도 낮기 때문이죠.

<br/>

### 클러스터 시스템

여러개의 시스템이 `네트워크`로 묶인 `하나의 거대한 시스템`을 의미합니다. `다중 처리기 시스템`이 컴퓨터 1개로만 이루어진 시스템이라면 `클러스터 시스템`은 컴퓨터 N개가 묶인 시스템입니다. 어떤 시스템이 다운되더라도 다른 시스템이 살아 있으므로 `높은 가용성`을 보장할 수 있습니다. 다만, `유지보수`가 어려워지며 전체 성능이 `네트워크의 품질`에 의해 심하게 변동됩니다.

<br/>

`다중 처리기 시스템`과 마찬가지로 `대칭형 시스템`과 `비대칭형 시스템`이 존재합니다. 다만 `비대칭형 시스템`은 시스템 하나를 사용할 수 없으므로 매우 큰 손해입니다. 따라서 모든 컴퓨터를 가용할 수 있는 `대칭형 시스템`이 보편적으로 사용됩니다.

<br/>

# 운영체제의 구성 요소

## 프로세스 관리

### 프로그램

프로그램은 `CPU`에 의해 실행되지 않으면 아무 일도 할 수 없습니다. 즉, 프로그램 그 자체는 `명령어로 이루어진 단순한 데이터 덩어리`이며 운영체제에 의해 `자원`과 다음 실행할 명령어의 주소를 가르키는 `프로그램 카운터`가 할당되어야만(=`실행할 준비가 되어서야`) 비로소 의미를 갖습니다. 즉, 프로그램은 프로그램 카운터가 없는 `수동적 개체`입니다.

<br/>

### 프로세스

운영체제가 `프로그램`에 `자원`과 `프로그램 카운터`를 할당하여 실행할 준비가 된 것을 `프로세스`라고 합니다. 각각의 프로세스는 자신만의 `고유 자원`을 갖고, 하나 이상의 `쓰레드`로 구성됩니다. 즉, 프로세스는 프로그램 카운터가 존재하는 `능동적 개체`입니다.

<br/>

### 쓰레드

프로세스를 이루는 더 작은 작업의 단위입니다. `프로세스`의 공유 자원에 접근할 수 있고, 각 쓰레드는 프로그램 카운터를 비롯한 자신만의 `고유 자원`을 갖습니다. 프로세스에서 설명했던 `프로그램 카운터`는 정확히는 프로세스를 이루는 쓰레드들이 하나씩 가지고 있습니다.

<br/>

### 멀티 프로세싱

하나의 컴퓨터에서 여러개의 프로세스가 실행되는 것은 드문일이 아닙니다. 모든 프로세스(와 쓰레드)는 매우 작은 단위로 쪼개서, 번갈아 가면서 실행하는 형태로 `병렬 처리`될 수 있습니다.

<br/>

## 메모리 관리

### 효율적인 관리 알고리즘

`폰 노이만 구조`에 의하면 프로그램이 실행되기 위해서는 `메인 메모리`에 먼저 적재되어야 합니다. 그러나 `매우 큰 프로그램`  
의 모든 부분을 램에 적재할 수 없으므로 프로그램을 잘게 쪼개어 부분부분 적재하는데, 적재되지 않은 부분이 필요하다면 프로그램의 진행을 잠시 멈추고 `Disk I/O`를 발생시켜 해당 부분을 적재시킨 뒤에 다시 진행하는 방식을 사용합니다.

<br/>

시간이 흘러 메모리가 꽉 찼다면 적재된 부분들 중 하나를 골라내어 삭제해야 합니다. 이 때 `자주 사용하는 부분`이 삭제되었다면 성능이 급감하겠죠. 운영체제는 이러한 현상을 막기 위해 효율적으로 메모리를 적재하고 삭제하는 알고리즘을 제공해야 합니다.

<br/>

### 메모리 추적

하나의 프로세스가 메모리를 독점하면 안되므로 `누가` `얼만큼` `어디를` `마지막으로 언제` 사용하고 있는지 추적해야 합니다. 이러한 정보들은 메모리가 꽉 찼을 때 `필요없는 부분`을 끌어내리는데 사용할 판단 지표로 사용될 수 있습니다.

<br/>

## 저장장치 관리

### 파일 시스템 관리

운영체제는 `다양한 보조 저장매체`들을 어떻게 제어할 것 인지, 데이터의 계층 구조를 어떻게 표현할 것 인지, 다수의 사용자가 하나의 파일에 동시에 접근할 때 어떻게 통제할 것 인지 생각해야 합니다. 이러한 역할을 수행하는 지점이 `파일 시스템`입니다.

<br/>

### 대용량 저장장치 관리

`주 메모리`는 전기가 끊기면 내용이 사라지는 `휘발성 저장장치`이므로 내용을 영구적으로 저장하기 위해서는 `비휘발성 저장장치`가 필요합니다. 데이터가 시작하는 지점도 `비휘발성 매체`이고, 연산 결과가 쓰여지는 지점도 `비휘발성 매체`이므로 운영체제는 `대용량 저장장치`의 성능을 효과적으로 이끌어내기 위한 전략을 제공해야 합니다. ex) `디스크 스케쥴링`

<br/>

### 캐싱

캐시는 매우 빠르지만 가용량이 매우 적은 휘발성 메모리입니다. 따라서 빈번하게 요구되는 데이터가 캐싱되어야만 전체 성능의 향상을 노릴 수 있습니다. 운영체제는 `캐싱`의 성능을 효과적으로 이끌어내기 위한 전략을 제공해야 합니다. ex) `캐싱할 데이터 선택 전략`

<br/>

### 입출력 시스템

사용자는 단순히 `장치`가 있다고만 알고 있어야 하며, 해당 장치의 세부적 또는 물리적인 특성은 오직 `드라이버`만이 알고 있어야 합니다. 운영체제는 다양한 `장치`들을 관리하는 시스템과, 장치들이 서로 통신할 수 있도록 인터페이스를 제공해야 합니다.

<br/>

# 전용 시스템

`범용 시스템`과 달리 특정 목적만을 이루기 위해 제작된 시스템을 `전용 시스템`이라고 합니다.

<br/>

## 실시간 임베디드 시스템

사용자 인터페이스가 없거나 극도로 제한된 시스템입니다. 장치의 상태를 감시하는데 초점이 맞춰져 있으며, 필요에 따라 정해진 패널에 데이터를 렌더링합니다. ex) `자판기`, `전자레인지`, `자동차 블랙박스`

<br/>

## 멀티미디어 시스템

동영상의 처리를 전문적으로 하는 시스템. 시스템이 다루는 범위가 텍스트만이 아니라는 것을 보여줍니다.

<br/>

## 휴대용 시스템

휴대 장치에서 사용되는 운영체제입니다. 대체로 데스크탑보다 성능도 낮고, 화면도 작지만 `편리성`이 이러한 단점들을 상쇄합니다. `소모 전력량`과 같이 일반적으로 고려되지 않는 특수한 문제에 대해 고민해야 합니다.

<br/>

# 계산 환경

## 전통적 환경

옛날에는 단일 시스템만을 사용하여 계산을 진행했습니다. 사용자가 컴퓨터에 앉아 `대화형 터미널`을 통해 데이터를 입력하면, 계산을 완료한 후 파일이나 터미널에 출력합니다. 효율적으로 사용하기 위해 서로 컴퓨터를 이용하는 시간을 협의해야 했습니다.

<br/>

## 클라이언트-서버 컴퓨팅

`PC`가 보다 강력해지고 가격도 낮아짐에 따라 `계산 컴퓨터`(= `중앙 시스템`) 앞에서 줄을 설 필요가 없어졌습니다. `중앙 시스템`에 연결된 주변장치를 통해 수행되었던 `사용자 인터페이스`의 기능들이 `클라이언트 PC`와 `네트워크`로 인해 대체되었습니다.

<br/>

## 피어-피어 컴퓨팅

`클라이언트-서버` 구조는 `계산하는 컴퓨터`와 `접속하는 컴퓨터`로 나눠져있지만 `피어` 구조는 모두가 평등하게 `계산하는 컴퓨터`로 이루어져있습니다. 다만 `피어 네트워크`에 참가되어 있어야 하며, 다른 피어를 찾는 전략이 정의되어 있어야 합니다. 보통 다음 두가지 전략 중 하나를 사용합니다.

1.  가용 피어 목록을 관리하는 `중앙 서버`를 만듭니다.
2.  모든 네트워크에 메세지를 날려서 반응이 올 때까지 기다립니다. 이 경우, 특수한 프로토콜을 설계해야 합니다.
